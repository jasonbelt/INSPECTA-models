// #Sireum

package base.SW

import org.sireum._
import base._

// Do not edit this file as it will be overwritten if HAMR codegen is rerun
object Firewall_Impl_seL4_Firewall_Firewall_GumboX {
  /** Compute Entrypoint Contract
    *
    * guarantee RC_INSPECTA_00_HLR_2
    *   1.2 firewall: drop ipv6 frames (RC_INSPECTA_00-HLR-2))) The firewall shall drop any frame that is type ipv6.
    * @param api_EthernetFramesRxIn incoming event data port
    * @param api_EthernetFramesTxIn incoming event data port
    * @param api_EthernetFramesRxOut outgoing event data port
    * @param api_EthernetFramesTxOut outgoing event data port
    */
  @strictpure def compute_spec_RC_INSPECTA_00_HLR_2_guarantee(
      api_EthernetFramesRxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesTxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesRxOut: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesTxOut: Option[SW.StructuredEthernetMessage_i]): B =
    (api_EthernetFramesRxIn.nonEmpty &&
       SW.GUMBO__Library.getInternetProtocol(api_EthernetFramesRxIn.get) == SW.InternetProtocol.IPV6) ->: api_EthernetFramesRxOut.isEmpty &
      (api_EthernetFramesTxIn.nonEmpty && SW.GUMBO__Library.isIPV6(api_EthernetFramesTxIn.get)) ->: api_EthernetFramesTxOut.isEmpty

  /** Compute Entrypoint Contract
    *
    * guarantee RC_INSPECTA_00_HLR_4
    *   1.4 firewall: drop RxIn ipv4 tcp frames with unexpected ports (RC_INSPECTA_00-HLR- 4))) The firewall shall
    *   drop any frame from RxIn that is an Ipv4 frame whose protocol is TCP and whose port is not defined in the port whitelist.
    * @param api_EthernetFramesRxIn incoming event data port
    * @param api_EthernetFramesRxOut outgoing event data port
    */
  @strictpure def compute_spec_RC_INSPECTA_00_HLR_4_guarantee(
      api_EthernetFramesRxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesRxOut: Option[SW.StructuredEthernetMessage_i]): B =
    (api_EthernetFramesRxIn.nonEmpty &&
       (SW.GUMBO__Library.isIPV4(api_EthernetFramesRxIn.get) & SW.GUMBO__Library.isTCP(api_EthernetFramesRxIn.get) &
         SW.GUMBO__Library.isPortWhitelisted(api_EthernetFramesRxIn.get))) ->: api_EthernetFramesRxOut.isEmpty

  /** Compute Entrypoint Contract
    *
    * guarantee RC_INSPECTA_00_HLR_5
    *   1.5 firewall: reply to RxIn arp requests (RC_INSPECTA_00-HLR-5))) If the firewall gets an Arp request frame from RxIn,
    *   the firewall shall send an Arp reply frame to TxOut.
    * @param api_EthernetFramesRxIn incoming event data port
    * @param api_EthernetFramesTxOut outgoing event data port
    */
  @strictpure def compute_spec_RC_INSPECTA_00_HLR_5_guarantee(
      api_EthernetFramesRxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesTxOut: Option[SW.StructuredEthernetMessage_i]): B =
    (api_EthernetFramesRxIn.nonEmpty && SW.GUMBO__Library.isARP_Request(api_EthernetFramesRxIn.get)) ->: api_EthernetFramesTxOut.nonEmpty &
      SW.GUMBO__Library.isARP_Reply(api_EthernetFramesTxOut.get)

  /** Compute Entrypoint Contract
    *
    * guarantee RC_INSPECTA_00_HLR_6
    *   1.6 firewall: copy through allowed tcp port packets (RC_INSPECTA_00-HLR-6))) The firewall shall copy any frame from RxIn 
    *   that is an Ipv4 frame with the TCP protocol and whose port is defined in the port whitelist to RxOut.
    * @param api_EthernetFramesRxIn incoming event data port
    * @param api_EthernetFramesRxOut outgoing event data port
    */
  @strictpure def compute_spec_RC_INSPECTA_00_HLR_6_guarantee(
      api_EthernetFramesRxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesRxOut: Option[SW.StructuredEthernetMessage_i]): B =
    (api_EthernetFramesRxIn.nonEmpty &&
       (SW.GUMBO__Library.isIPV4(api_EthernetFramesRxIn.get) & SW.GUMBO__Library.isTCP(api_EthernetFramesRxIn.get) &
         SW.GUMBO__Library.isPortWhitelisted(api_EthernetFramesRxIn.get))) ->: (api_EthernetFramesRxOut.nonEmpty &&
       api_EthernetFramesRxIn.get == api_EthernetFramesRxOut.get)

  /** Compute Entrypoint Contract
    *
    * guarantee RC_INSPECTA_00_HLR_7
    *   1.7 firewall: copy out tx arp and ipv4 frames (RC_INSPECTA_00-HLR-7))) The firewall shall copy any frame from TxIn that
    *   is an Ipv4 or Arp frame to TxOut.
    * @param api_EthernetFramesRxIn incoming event data port
    * @param api_EthernetFramesTxIn incoming event data port
    * @param api_EthernetFramesTxOut outgoing event data port
    */
  @strictpure def compute_spec_RC_INSPECTA_00_HLR_7_guarantee(
      api_EthernetFramesRxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesTxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesTxOut: Option[SW.StructuredEthernetMessage_i]): B =
    (api_EthernetFramesTxIn.nonEmpty &&
       (SW.GUMBO__Library.isIPV4(api_EthernetFramesTxIn.get) | SW.GUMBO__Library.isARP(api_EthernetFramesRxIn.get))) ->: (api_EthernetFramesTxOut.nonEmpty &&
       api_EthernetFramesTxIn.get == api_EthernetFramesTxOut.get)

  /** CEP-T-Guar: Top-level guarantee contracts for Firewall's compute entrypoint
    *
    * @param api_EthernetFramesRxIn incoming event data port
    * @param api_EthernetFramesTxIn incoming event data port
    * @param api_EthernetFramesRxOut outgoing event data port
    * @param api_EthernetFramesTxOut outgoing event data port
    */
  @strictpure def compute_CEP_T_Guar (
      api_EthernetFramesRxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesTxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesRxOut: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesTxOut: Option[SW.StructuredEthernetMessage_i]): B =
    compute_spec_RC_INSPECTA_00_HLR_2_guarantee(api_EthernetFramesRxIn, api_EthernetFramesTxIn, api_EthernetFramesRxOut, api_EthernetFramesTxOut) &
    compute_spec_RC_INSPECTA_00_HLR_4_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut) &
    compute_spec_RC_INSPECTA_00_HLR_5_guarantee(api_EthernetFramesRxIn, api_EthernetFramesTxOut) &
    compute_spec_RC_INSPECTA_00_HLR_6_guarantee(api_EthernetFramesRxIn, api_EthernetFramesRxOut) &
    compute_spec_RC_INSPECTA_00_HLR_7_guarantee(api_EthernetFramesRxIn, api_EthernetFramesTxIn, api_EthernetFramesTxOut)

  /** CEP-Post: Compute Entrypoint Post-Condition for Firewall
    *
    * @param api_EthernetFramesRxIn incoming event data port
    * @param api_EthernetFramesTxIn incoming event data port
    * @param api_EthernetFramesRxOut outgoing event data port
    * @param api_EthernetFramesTxOut outgoing event data port
    */
  @strictpure def compute_CEP_Post (
      api_EthernetFramesRxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesTxIn: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesRxOut: Option[SW.StructuredEthernetMessage_i],
      api_EthernetFramesTxOut: Option[SW.StructuredEthernetMessage_i]): B =
    (// CEP-Guar: guarantee clauses of Firewall's compute entrypoint
     compute_CEP_T_Guar (api_EthernetFramesRxIn, api_EthernetFramesTxIn, api_EthernetFramesRxOut, api_EthernetFramesTxOut))

  /** CEP-Post: Compute Entrypoint Post-Condition for Firewall via containers
    *
    * @param pre Container holding the values of incoming ports and the pre-state values of state variables
    * @param post Container holding the values of outgoing ports and the post-state values of state variables
    */
  @strictpure def compute_CEP_Post_Container(
      pre: Firewall_Impl_seL4_Firewall_Firewall_PreState_Container_PS,
      post: Firewall_Impl_seL4_Firewall_Firewall_PostState_Container_PS): B =
    compute_CEP_Post(
      api_EthernetFramesRxIn = pre.api_EthernetFramesRxIn,
      api_EthernetFramesTxIn = pre.api_EthernetFramesTxIn,
      api_EthernetFramesRxOut = post.api_EthernetFramesRxOut,
      api_EthernetFramesTxOut = post.api_EthernetFramesTxOut)
}
