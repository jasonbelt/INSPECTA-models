#include "consumer_consumer.h"

// Do not edit this file as it will be overwritten if codegen is rerun

void consumer_consumer_initialize(void);
void consumer_consumer_notify(microkit_channel channel);
void consumer_consumer_timeTriggered(void);

volatile sb_queue_bool_1_t *myBoolean_queue_1;
sb_queue_bool_1_Recv_t myBoolean_recv_queue;
volatile sb_queue_char_1_t *myCharacter_queue_1;
sb_queue_char_1_Recv_t myCharacter_recv_queue;
volatile sb_queue_String_1_t *myString_queue_1;
sb_queue_String_1_Recv_t myString_recv_queue;
volatile sb_queue_int8_t_1_t *myInt8_queue_1;
sb_queue_int8_t_1_Recv_t myInt8_recv_queue;
volatile sb_queue_int16_t_1_t *myInt16_queue_1;
sb_queue_int16_t_1_Recv_t myInt16_recv_queue;
volatile sb_queue_int32_t_1_t *myInt32_queue_1;
sb_queue_int32_t_1_Recv_t myInt32_recv_queue;
volatile sb_queue_int64_t_1_t *myInt64_queue_1;
sb_queue_int64_t_1_Recv_t myInt64_recv_queue;
volatile sb_queue_uint8_t_1_t *myUInt8_queue_1;
sb_queue_uint8_t_1_Recv_t myUInt8_recv_queue;
volatile sb_queue_uint16_t_1_t *myUInt16_queue_1;
sb_queue_uint16_t_1_Recv_t myUInt16_recv_queue;
volatile sb_queue_uint32_t_1_t *myUInt32_queue_1;
sb_queue_uint32_t_1_Recv_t myUInt32_recv_queue;
volatile sb_queue_uint64_t_1_t *myUInt64_queue_1;
sb_queue_uint64_t_1_Recv_t myUInt64_recv_queue;
volatile sb_queue_float_1_t *myFloat32_queue_1;
sb_queue_float_1_Recv_t myFloat32_recv_queue;
volatile sb_queue_double_1_t *myFloat64_queue_1;
sb_queue_double_1_Recv_t myFloat64_recv_queue;
volatile sb_queue_base_Aadl_Datatypes_MyEnum_Type_1_t *myEnum_queue_1;
sb_queue_base_Aadl_Datatypes_MyEnum_Type_1_Recv_t myEnum_recv_queue;
volatile sb_queue_base_Aadl_Datatypes_MyStruct_i_1_t *myStruct_queue_1;
sb_queue_base_Aadl_Datatypes_MyStruct_i_1_Recv_t myStruct_recv_queue;
volatile sb_queue_base_Aadl_Datatypes_MyArrayOneDim_1_t *myArray1_queue_1;
sb_queue_base_Aadl_Datatypes_MyArrayOneDim_1_Recv_t myArray1_recv_queue;

#define PORT_FROM_MON 58

bool myBoolean_is_empty(void) {
  return sb_queue_bool_1_is_empty(&myBoolean_recv_queue);
}

bool get_myBoolean_poll(sb_event_counter_t *numDropped, bool *data) {
  return sb_queue_bool_1_dequeue((sb_queue_bool_1_Recv_t *) &myBoolean_recv_queue, numDropped, data);
}

bool get_myBoolean(bool *data) {
  sb_event_counter_t numDropped;
  return get_myBoolean_poll (&numDropped, data);
}

bool myCharacter_is_empty(void) {
  return sb_queue_char_1_is_empty(&myCharacter_recv_queue);
}

bool get_myCharacter_poll(sb_event_counter_t *numDropped, char *data) {
  return sb_queue_char_1_dequeue((sb_queue_char_1_Recv_t *) &myCharacter_recv_queue, numDropped, data);
}

bool get_myCharacter(char *data) {
  sb_event_counter_t numDropped;
  return get_myCharacter_poll (&numDropped, data);
}

bool myString_is_empty(void) {
  return sb_queue_String_1_is_empty(&myString_recv_queue);
}

bool get_myString_poll(sb_event_counter_t *numDropped, String *data) {
  return sb_queue_String_1_dequeue((sb_queue_String_1_Recv_t *) &myString_recv_queue, numDropped, data);
}

bool get_myString(String *data) {
  sb_event_counter_t numDropped;
  return get_myString_poll (&numDropped, data);
}

bool myInt8_is_empty(void) {
  return sb_queue_int8_t_1_is_empty(&myInt8_recv_queue);
}

bool get_myInt8_poll(sb_event_counter_t *numDropped, int8_t *data) {
  return sb_queue_int8_t_1_dequeue((sb_queue_int8_t_1_Recv_t *) &myInt8_recv_queue, numDropped, data);
}

bool get_myInt8(int8_t *data) {
  sb_event_counter_t numDropped;
  return get_myInt8_poll (&numDropped, data);
}

bool myInt16_is_empty(void) {
  return sb_queue_int16_t_1_is_empty(&myInt16_recv_queue);
}

bool get_myInt16_poll(sb_event_counter_t *numDropped, int16_t *data) {
  return sb_queue_int16_t_1_dequeue((sb_queue_int16_t_1_Recv_t *) &myInt16_recv_queue, numDropped, data);
}

bool get_myInt16(int16_t *data) {
  sb_event_counter_t numDropped;
  return get_myInt16_poll (&numDropped, data);
}

bool myInt32_is_empty(void) {
  return sb_queue_int32_t_1_is_empty(&myInt32_recv_queue);
}

bool get_myInt32_poll(sb_event_counter_t *numDropped, int32_t *data) {
  return sb_queue_int32_t_1_dequeue((sb_queue_int32_t_1_Recv_t *) &myInt32_recv_queue, numDropped, data);
}

bool get_myInt32(int32_t *data) {
  sb_event_counter_t numDropped;
  return get_myInt32_poll (&numDropped, data);
}

bool myInt64_is_empty(void) {
  return sb_queue_int64_t_1_is_empty(&myInt64_recv_queue);
}

bool get_myInt64_poll(sb_event_counter_t *numDropped, int64_t *data) {
  return sb_queue_int64_t_1_dequeue((sb_queue_int64_t_1_Recv_t *) &myInt64_recv_queue, numDropped, data);
}

bool get_myInt64(int64_t *data) {
  sb_event_counter_t numDropped;
  return get_myInt64_poll (&numDropped, data);
}

bool myUInt8_is_empty(void) {
  return sb_queue_uint8_t_1_is_empty(&myUInt8_recv_queue);
}

bool get_myUInt8_poll(sb_event_counter_t *numDropped, uint8_t *data) {
  return sb_queue_uint8_t_1_dequeue((sb_queue_uint8_t_1_Recv_t *) &myUInt8_recv_queue, numDropped, data);
}

bool get_myUInt8(uint8_t *data) {
  sb_event_counter_t numDropped;
  return get_myUInt8_poll (&numDropped, data);
}

bool myUInt16_is_empty(void) {
  return sb_queue_uint16_t_1_is_empty(&myUInt16_recv_queue);
}

bool get_myUInt16_poll(sb_event_counter_t *numDropped, uint16_t *data) {
  return sb_queue_uint16_t_1_dequeue((sb_queue_uint16_t_1_Recv_t *) &myUInt16_recv_queue, numDropped, data);
}

bool get_myUInt16(uint16_t *data) {
  sb_event_counter_t numDropped;
  return get_myUInt16_poll (&numDropped, data);
}

bool myUInt32_is_empty(void) {
  return sb_queue_uint32_t_1_is_empty(&myUInt32_recv_queue);
}

bool get_myUInt32_poll(sb_event_counter_t *numDropped, uint32_t *data) {
  return sb_queue_uint32_t_1_dequeue((sb_queue_uint32_t_1_Recv_t *) &myUInt32_recv_queue, numDropped, data);
}

bool get_myUInt32(uint32_t *data) {
  sb_event_counter_t numDropped;
  return get_myUInt32_poll (&numDropped, data);
}

bool myUInt64_is_empty(void) {
  return sb_queue_uint64_t_1_is_empty(&myUInt64_recv_queue);
}

bool get_myUInt64_poll(sb_event_counter_t *numDropped, uint64_t *data) {
  return sb_queue_uint64_t_1_dequeue((sb_queue_uint64_t_1_Recv_t *) &myUInt64_recv_queue, numDropped, data);
}

bool get_myUInt64(uint64_t *data) {
  sb_event_counter_t numDropped;
  return get_myUInt64_poll (&numDropped, data);
}

bool myFloat32_is_empty(void) {
  return sb_queue_float_1_is_empty(&myFloat32_recv_queue);
}

bool get_myFloat32_poll(sb_event_counter_t *numDropped, float *data) {
  return sb_queue_float_1_dequeue((sb_queue_float_1_Recv_t *) &myFloat32_recv_queue, numDropped, data);
}

bool get_myFloat32(float *data) {
  sb_event_counter_t numDropped;
  return get_myFloat32_poll (&numDropped, data);
}

bool myFloat64_is_empty(void) {
  return sb_queue_double_1_is_empty(&myFloat64_recv_queue);
}

bool get_myFloat64_poll(sb_event_counter_t *numDropped, double *data) {
  return sb_queue_double_1_dequeue((sb_queue_double_1_Recv_t *) &myFloat64_recv_queue, numDropped, data);
}

bool get_myFloat64(double *data) {
  sb_event_counter_t numDropped;
  return get_myFloat64_poll (&numDropped, data);
}

bool myEnum_is_empty(void) {
  return sb_queue_base_Aadl_Datatypes_MyEnum_Type_1_is_empty(&myEnum_recv_queue);
}

bool get_myEnum_poll(sb_event_counter_t *numDropped, base_Aadl_Datatypes_MyEnum_Type *data) {
  return sb_queue_base_Aadl_Datatypes_MyEnum_Type_1_dequeue((sb_queue_base_Aadl_Datatypes_MyEnum_Type_1_Recv_t *) &myEnum_recv_queue, numDropped, data);
}

bool get_myEnum(base_Aadl_Datatypes_MyEnum_Type *data) {
  sb_event_counter_t numDropped;
  return get_myEnum_poll (&numDropped, data);
}

bool myStruct_is_empty(void) {
  return sb_queue_base_Aadl_Datatypes_MyStruct_i_1_is_empty(&myStruct_recv_queue);
}

bool get_myStruct_poll(sb_event_counter_t *numDropped, base_Aadl_Datatypes_MyStruct_i *data) {
  return sb_queue_base_Aadl_Datatypes_MyStruct_i_1_dequeue((sb_queue_base_Aadl_Datatypes_MyStruct_i_1_Recv_t *) &myStruct_recv_queue, numDropped, data);
}

bool get_myStruct(base_Aadl_Datatypes_MyStruct_i *data) {
  sb_event_counter_t numDropped;
  return get_myStruct_poll (&numDropped, data);
}

bool myArray1_is_empty(void) {
  return sb_queue_base_Aadl_Datatypes_MyArrayOneDim_1_is_empty(&myArray1_recv_queue);
}

bool get_myArray1_poll(sb_event_counter_t *numDropped, base_Aadl_Datatypes_MyArrayOneDim *data) {
  return sb_queue_base_Aadl_Datatypes_MyArrayOneDim_1_dequeue((sb_queue_base_Aadl_Datatypes_MyArrayOneDim_1_Recv_t *) &myArray1_recv_queue, numDropped, data);
}

bool get_myArray1(base_Aadl_Datatypes_MyArrayOneDim *data) {
  sb_event_counter_t numDropped;
  return get_myArray1_poll (&numDropped, data);
}

void init(void) {
  sb_queue_bool_1_Recv_init(&myBoolean_recv_queue, (sb_queue_bool_1_t *) myBoolean_queue_1);

  sb_queue_char_1_Recv_init(&myCharacter_recv_queue, (sb_queue_char_1_t *) myCharacter_queue_1);

  sb_queue_String_1_Recv_init(&myString_recv_queue, (sb_queue_String_1_t *) myString_queue_1);

  sb_queue_int8_t_1_Recv_init(&myInt8_recv_queue, (sb_queue_int8_t_1_t *) myInt8_queue_1);

  sb_queue_int16_t_1_Recv_init(&myInt16_recv_queue, (sb_queue_int16_t_1_t *) myInt16_queue_1);

  sb_queue_int32_t_1_Recv_init(&myInt32_recv_queue, (sb_queue_int32_t_1_t *) myInt32_queue_1);

  sb_queue_int64_t_1_Recv_init(&myInt64_recv_queue, (sb_queue_int64_t_1_t *) myInt64_queue_1);

  sb_queue_uint8_t_1_Recv_init(&myUInt8_recv_queue, (sb_queue_uint8_t_1_t *) myUInt8_queue_1);

  sb_queue_uint16_t_1_Recv_init(&myUInt16_recv_queue, (sb_queue_uint16_t_1_t *) myUInt16_queue_1);

  sb_queue_uint32_t_1_Recv_init(&myUInt32_recv_queue, (sb_queue_uint32_t_1_t *) myUInt32_queue_1);

  sb_queue_uint64_t_1_Recv_init(&myUInt64_recv_queue, (sb_queue_uint64_t_1_t *) myUInt64_queue_1);

  sb_queue_float_1_Recv_init(&myFloat32_recv_queue, (sb_queue_float_1_t *) myFloat32_queue_1);

  sb_queue_double_1_Recv_init(&myFloat64_recv_queue, (sb_queue_double_1_t *) myFloat64_queue_1);

  sb_queue_base_Aadl_Datatypes_MyEnum_Type_1_Recv_init(&myEnum_recv_queue, (sb_queue_base_Aadl_Datatypes_MyEnum_Type_1_t *) myEnum_queue_1);

  sb_queue_base_Aadl_Datatypes_MyStruct_i_1_Recv_init(&myStruct_recv_queue, (sb_queue_base_Aadl_Datatypes_MyStruct_i_1_t *) myStruct_queue_1);

  sb_queue_base_Aadl_Datatypes_MyArrayOneDim_1_Recv_init(&myArray1_recv_queue, (sb_queue_base_Aadl_Datatypes_MyArrayOneDim_1_t *) myArray1_queue_1);

  consumer_consumer_initialize();
}

void notified(microkit_channel channel) {
  switch (channel) {
    case PORT_FROM_MON:
      consumer_consumer_timeTriggered();
      break;
    default:
      consumer_consumer_notify(channel);
  }
}
