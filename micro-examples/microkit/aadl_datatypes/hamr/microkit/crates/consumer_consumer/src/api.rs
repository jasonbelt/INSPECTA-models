#![allow(dead_code)]
#![allow(non_snake_case)]

// Do not edit this file as it will be overwritten if codegen is rerun

use types::*;

extern "C" {
  pub fn myBoolean_is_empty() -> bool;
  pub fn get_myBoolean_poll(num_dropped: *mut sb_event_counter_t, data: *mut bool);
  pub fn get_myBoolean(data: *mut bool) -> bool;
  pub fn myCharacter_is_empty() -> bool;
  pub fn get_myCharacter_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::c_char);
  pub fn get_myCharacter(data: *mut cty::c_char) -> bool;
  pub fn myString_is_empty() -> bool;
  pub fn get_myString_poll(num_dropped: *mut sb_event_counter_t, data: *mut String);
  pub fn get_myString(data: *mut String) -> bool;
  pub fn myInt8_is_empty() -> bool;
  pub fn get_myInt8_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::int8_t);
  pub fn get_myInt8(data: *mut cty::int8_t) -> bool;
  pub fn myInt16_is_empty() -> bool;
  pub fn get_myInt16_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::int16_t);
  pub fn get_myInt16(data: *mut cty::int16_t) -> bool;
  pub fn myInt32_is_empty() -> bool;
  pub fn get_myInt32_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::int32_t);
  pub fn get_myInt32(data: *mut cty::int32_t) -> bool;
  pub fn myInt64_is_empty() -> bool;
  pub fn get_myInt64_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::int64_t);
  pub fn get_myInt64(data: *mut cty::int64_t) -> bool;
  pub fn myUInt8_is_empty() -> bool;
  pub fn get_myUInt8_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::uint8_t);
  pub fn get_myUInt8(data: *mut cty::uint8_t) -> bool;
  pub fn myUInt16_is_empty() -> bool;
  pub fn get_myUInt16_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::uint16_t);
  pub fn get_myUInt16(data: *mut cty::uint16_t) -> bool;
  pub fn myUInt32_is_empty() -> bool;
  pub fn get_myUInt32_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::uint32_t);
  pub fn get_myUInt32(data: *mut cty::uint32_t) -> bool;
  pub fn myUInt64_is_empty() -> bool;
  pub fn get_myUInt64_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::uint64_t);
  pub fn get_myUInt64(data: *mut cty::uint64_t) -> bool;
  pub fn myFloat32_is_empty() -> bool;
  pub fn get_myFloat32_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::c_float);
  pub fn get_myFloat32(data: *mut cty::c_float) -> bool;
  pub fn myFloat64_is_empty() -> bool;
  pub fn get_myFloat64_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::c_double);
  pub fn get_myFloat64(data: *mut cty::c_double) -> bool;
  pub fn myEnum_is_empty() -> bool;
  pub fn get_myEnum_poll(num_dropped: *mut sb_event_counter_t, data: *mut base_Aadl_Datatypes_MyEnum_Type);
  pub fn get_myEnum(data: *mut base_Aadl_Datatypes_MyEnum_Type) -> bool;
  pub fn myStruct_is_empty() -> bool;
  pub fn get_myStruct_poll(num_dropped: *mut sb_event_counter_t, data: *mut base_Aadl_Datatypes_MyStruct_i);
  pub fn get_myStruct(data: *mut base_Aadl_Datatypes_MyStruct_i) -> bool;
  pub fn myArray1_is_empty() -> bool;
  pub fn get_myArray1_poll(num_dropped: *mut sb_event_counter_t, data: *mut base_Aadl_Datatypes_MyArrayOneDim);
  pub fn get_myArray1(data: *mut base_Aadl_Datatypes_MyArrayOneDim) -> bool;
}

pub fn unsafe_myBoolean_is_empty() -> bool {
  return unsafe { myBoolean_is_empty() };
}

pub fn unsafe_get_myBoolean_poll(num_dropped: *mut sb_event_counter_t, data: *mut bool) {
  return unsafe { get_myBoolean_poll(num_dropped, data) };
}

pub fn unsafe_get_myBoolean(data: *mut bool) -> bool {
  return unsafe { get_myBoolean(data) };
}

pub fn unsafe_myCharacter_is_empty() -> bool {
  return unsafe { myCharacter_is_empty() };
}

pub fn unsafe_get_myCharacter_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::c_char) {
  return unsafe { get_myCharacter_poll(num_dropped, data) };
}

pub fn unsafe_get_myCharacter(data: *mut cty::c_char) -> bool {
  return unsafe { get_myCharacter(data) };
}

pub fn unsafe_myString_is_empty() -> bool {
  return unsafe { myString_is_empty() };
}

pub fn unsafe_get_myString_poll(num_dropped: *mut sb_event_counter_t, data: *mut String) {
  return unsafe { get_myString_poll(num_dropped, data) };
}

pub fn unsafe_get_myString(data: *mut String) -> bool {
  return unsafe { get_myString(data) };
}

pub fn unsafe_myInt8_is_empty() -> bool {
  return unsafe { myInt8_is_empty() };
}

pub fn unsafe_get_myInt8_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::int8_t) {
  return unsafe { get_myInt8_poll(num_dropped, data) };
}

pub fn unsafe_get_myInt8(data: *mut cty::int8_t) -> bool {
  return unsafe { get_myInt8(data) };
}

pub fn unsafe_myInt16_is_empty() -> bool {
  return unsafe { myInt16_is_empty() };
}

pub fn unsafe_get_myInt16_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::int16_t) {
  return unsafe { get_myInt16_poll(num_dropped, data) };
}

pub fn unsafe_get_myInt16(data: *mut cty::int16_t) -> bool {
  return unsafe { get_myInt16(data) };
}

pub fn unsafe_myInt32_is_empty() -> bool {
  return unsafe { myInt32_is_empty() };
}

pub fn unsafe_get_myInt32_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::int32_t) {
  return unsafe { get_myInt32_poll(num_dropped, data) };
}

pub fn unsafe_get_myInt32(data: *mut cty::int32_t) -> bool {
  return unsafe { get_myInt32(data) };
}

pub fn unsafe_myInt64_is_empty() -> bool {
  return unsafe { myInt64_is_empty() };
}

pub fn unsafe_get_myInt64_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::int64_t) {
  return unsafe { get_myInt64_poll(num_dropped, data) };
}

pub fn unsafe_get_myInt64(data: *mut cty::int64_t) -> bool {
  return unsafe { get_myInt64(data) };
}

pub fn unsafe_myUInt8_is_empty() -> bool {
  return unsafe { myUInt8_is_empty() };
}

pub fn unsafe_get_myUInt8_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::uint8_t) {
  return unsafe { get_myUInt8_poll(num_dropped, data) };
}

pub fn unsafe_get_myUInt8(data: *mut cty::uint8_t) -> bool {
  return unsafe { get_myUInt8(data) };
}

pub fn unsafe_myUInt16_is_empty() -> bool {
  return unsafe { myUInt16_is_empty() };
}

pub fn unsafe_get_myUInt16_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::uint16_t) {
  return unsafe { get_myUInt16_poll(num_dropped, data) };
}

pub fn unsafe_get_myUInt16(data: *mut cty::uint16_t) -> bool {
  return unsafe { get_myUInt16(data) };
}

pub fn unsafe_myUInt32_is_empty() -> bool {
  return unsafe { myUInt32_is_empty() };
}

pub fn unsafe_get_myUInt32_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::uint32_t) {
  return unsafe { get_myUInt32_poll(num_dropped, data) };
}

pub fn unsafe_get_myUInt32(data: *mut cty::uint32_t) -> bool {
  return unsafe { get_myUInt32(data) };
}

pub fn unsafe_myUInt64_is_empty() -> bool {
  return unsafe { myUInt64_is_empty() };
}

pub fn unsafe_get_myUInt64_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::uint64_t) {
  return unsafe { get_myUInt64_poll(num_dropped, data) };
}

pub fn unsafe_get_myUInt64(data: *mut cty::uint64_t) -> bool {
  return unsafe { get_myUInt64(data) };
}

pub fn unsafe_myFloat32_is_empty() -> bool {
  return unsafe { myFloat32_is_empty() };
}

pub fn unsafe_get_myFloat32_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::c_float) {
  return unsafe { get_myFloat32_poll(num_dropped, data) };
}

pub fn unsafe_get_myFloat32(data: *mut cty::c_float) -> bool {
  return unsafe { get_myFloat32(data) };
}

pub fn unsafe_myFloat64_is_empty() -> bool {
  return unsafe { myFloat64_is_empty() };
}

pub fn unsafe_get_myFloat64_poll(num_dropped: *mut sb_event_counter_t, data: *mut cty::c_double) {
  return unsafe { get_myFloat64_poll(num_dropped, data) };
}

pub fn unsafe_get_myFloat64(data: *mut cty::c_double) -> bool {
  return unsafe { get_myFloat64(data) };
}

pub fn unsafe_myEnum_is_empty() -> bool {
  return unsafe { myEnum_is_empty() };
}

pub fn unsafe_get_myEnum_poll(num_dropped: *mut sb_event_counter_t, data: *mut base_Aadl_Datatypes_MyEnum_Type) {
  return unsafe { get_myEnum_poll(num_dropped, data) };
}

pub fn unsafe_get_myEnum(data: *mut base_Aadl_Datatypes_MyEnum_Type) -> bool {
  return unsafe { get_myEnum(data) };
}

pub fn unsafe_myStruct_is_empty() -> bool {
  return unsafe { myStruct_is_empty() };
}

pub fn unsafe_get_myStruct_poll(num_dropped: *mut sb_event_counter_t, data: *mut base_Aadl_Datatypes_MyStruct_i) {
  return unsafe { get_myStruct_poll(num_dropped, data) };
}

pub fn unsafe_get_myStruct(data: *mut base_Aadl_Datatypes_MyStruct_i) -> bool {
  return unsafe { get_myStruct(data) };
}

pub fn unsafe_myArray1_is_empty() -> bool {
  return unsafe { myArray1_is_empty() };
}

pub fn unsafe_get_myArray1_poll(num_dropped: *mut sb_event_counter_t, data: *mut base_Aadl_Datatypes_MyArrayOneDim) {
  return unsafe { get_myArray1_poll(num_dropped, data) };
}

pub fn unsafe_get_myArray1(data: *mut base_Aadl_Datatypes_MyArrayOneDim) -> bool {
  return unsafe { get_myArray1(data) };
}
