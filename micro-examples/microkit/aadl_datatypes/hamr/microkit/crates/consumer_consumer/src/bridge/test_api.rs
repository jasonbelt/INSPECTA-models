// Do not edit this file as it will be overwritten if codegen is rerun

use crate::bridge::extern_c_api as extern_api;
use data::*;

#[cfg(test)]
pub fn put_myBoolean(value: bool) 
 {
   *extern_api::IN_myBoolean.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myCharacter(value: u8) 
 {
   *extern_api::IN_myCharacter.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myString(value: Base_Types::String) 
 {
   *extern_api::IN_myString.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myInt8(value: i8) 
 {
   *extern_api::IN_myInt8.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myInt16(value: i16) 
 {
   *extern_api::IN_myInt16.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myInt32(value: i32) 
 {
   *extern_api::IN_myInt32.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myInt64(value: i64) 
 {
   *extern_api::IN_myInt64.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myUInt8(value: u8) 
 {
   *extern_api::IN_myUInt8.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myUInt16(value: u16) 
 {
   *extern_api::IN_myUInt16.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myUInt32(value: u32) 
 {
   *extern_api::IN_myUInt32.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myUInt64(value: u64) 
 {
   *extern_api::IN_myUInt64.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myFloat32(value: f32) 
 {
   *extern_api::IN_myFloat32.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myFloat64(value: f64) 
 {
   *extern_api::IN_myFloat64.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myEnum(value: Aadl_Datatypes::MyEnum) 
 {
   *extern_api::IN_myEnum.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myStruct(value: Aadl_Datatypes::MyStruct_i) 
 {
   *extern_api::IN_myStruct.lock().unwrap() = Some(value)
 }

#[cfg(test)]
pub fn put_myArray1(value: Aadl_Datatypes::MyArrayOneDim) 
 {
   *extern_api::IN_myArray1.lock().unwrap() = Some(value)
 }