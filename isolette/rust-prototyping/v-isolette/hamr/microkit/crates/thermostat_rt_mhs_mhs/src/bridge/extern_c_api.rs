#![allow(dead_code)]
#![allow(non_snake_case)]


//! C-interface for the component.
//! This code must be unsafe.
//! Assumptions about correctness are introduced and need to verified by other means.

#[cfg(test)]
use std::sync::Mutex;

// Do not edit this file as it will be overwritten if codegen is rerun

use crate::data::Isolette_Data_Model::*;

#[cfg(not(test))]
extern "C" {
  pub fn get_upper_desired_temp(data: *mut Temp_i) -> bool;
  pub fn get_lower_desired_temp(data: *mut Temp_i) -> bool;
  pub fn put_heat_control(data: *mut On_Off) -> bool;
  pub fn get_regulator_mode(data: *mut Regulator_Mode) -> bool;
  pub fn get_current_tempWstatus(data: *mut TempWstatus_i) -> bool;
}

pub fn unsafe_get_upper_desired_temp() -> Temp_i {
  unsafe {
    let data: *mut Temp_i = &mut Temp_i::default();
    get_upper_desired_temp(data);
    return *data;
  }
}

pub fn unsafe_get_lower_desired_temp() -> Temp_i {
  unsafe {
    let data: *mut Temp_i = &mut Temp_i::default();
    get_lower_desired_temp(data);
    return *data;
  }
}

pub fn unsafe_put_heat_control(data: &On_Off) -> bool {
  let mut value: On_Off = *data;
  let valptr: *mut On_Off = &mut value;
  unsafe {
    return put_heat_control(valptr);
  }
}

pub fn unsafe_get_regulator_mode() -> Regulator_Mode {
  unsafe {
    let data: *mut Regulator_Mode = &mut Regulator_Mode::default();
    get_regulator_mode(data);
    return *data;
  }
}

pub fn unsafe_get_current_tempWstatus() -> TempWstatus_i {
  unsafe {
    let data: *mut TempWstatus_i = &mut TempWstatus_i::default();
    get_current_tempWstatus(data);
    return *data;
 };
}

//////////////////////////////////////////////////////////////////////////////////
// Testing Verions
//////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
lazy_static::lazy_static! {
  // simulate the global C variables that point to the microkit shared memory regions.  In a full 
  // microkit system we would be able to mutate the shared memory for out ports since they're r/w, 
  // but we couldn't do that for in ports since they are read-only
  pub static ref OUT_heat_control: Mutex<Option<On_Off>> = Mutex::new(None);

  pub static ref IN_upper_desired_temp: Mutex<Option<Temp_i>> = Mutex::new(None);
  pub static ref IN_lower_desired_temp: Mutex<Option<Temp_i>> = Mutex::new(None);
  pub static ref IN_regulator_mode: Mutex<Option<Regulator_Mode>> = Mutex::new(None);
  pub static ref IN_current_tempWstatus: Mutex<Option<TempWstatus_i>> = Mutex::new(None);
}

#[cfg(test)]
pub fn put_heat_control(data: *mut On_Off) -> bool {
  unsafe {
    *OUT_heat_control.lock().unwrap() = Some(*data);
    return true;
  }
}

#[cfg(test)]
pub fn get_upper_desired_temp(data: *mut Temp_i) -> bool {
  unsafe {
    *data = IN_upper_desired_temp.lock().unwrap().expect("Not expecting None");
    return true;
  }
}

#[cfg(test)]
pub fn get_lower_desired_temp(data: *mut Temp_i) -> bool {
  unsafe {
    *data = IN_lower_desired_temp.lock().unwrap().expect("Not expecting None");
    return true;
  }
}

#[cfg(test)]
pub fn get_regulator_mode(data: *mut Regulator_Mode) -> bool {
  unsafe {
    *data = IN_regulator_mode.lock().unwrap().expect("Not expecting None");
    return true;
  }
}

#[cfg(test)]
pub fn get_current_tempWstatus(data: *mut TempWstatus_i) -> bool {
  unsafe {
    *data = IN_current_tempWstatus.lock().unwrap().expect("Not expecting None");
    return true;
  }
}
