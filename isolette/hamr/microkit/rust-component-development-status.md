# Status of Development of HAMR Rust Isolette Implementation

Last update of these notes: August 1, 2025

Next steps:
- clean up manual tests on MRM and MMM.  Replace helper macros with
  helper functions
- implement complete tests for MRI
- clean up manual tests for MHS  
- Implement app code and tests for MMI and MA
- Implement prop tests for all




## Regulate Subsystem

### Manage Heat Source 

- *Component Implementation* (done)
- *Manual Testing* (done (tests in long form without helper function)
  - 1 test for each requirement - coverage not checked); 
    ToDo: re-state tests using helper functions (preferrably ones
    auto-generated by HAMR)
- *PropTest Testing* - done. Has auto-generated tests with default
  generators commented out and replaced by custom ranges.   Can we
  have a version of the tests that leave the default generators so
  that we can demo the difference between default generators and
  custom generators.

### Manage Regulator Interface

- *Component Implementation* (done)
- *Manual Testing* (a few tests -- need to complete all tests with
  helper functions)

### Manage Regulator Mode

- *Component Implementation* (done)
- *Manual Testing* (done - comprehensive, as supported by Grok.  This
  component contains the most comprehensive illustrations of different
  forms of testing)

## Monitor Subsystem

## Manage Alarm

- *Component Implementation* -- TBD
- *Manual Testing* -- TBD

## Manage Monitor Interface

- *Component Implementation* -- Done and Verus verified
- *Manual Testing* -- TBD

## Manage Monitor Mode

- *Component Implementation* (done)
- *Manual Testing* (almost done - tests adapted from Grok tests in MRM.  Need
  to double check; comment at the bottom of the file indicates that a
  few tests still might be missing.  Need to convert helper macros to
  helper functions, following approach illustrated in MRM)

## Jason - Suggestions for Enhancing Testing Framework

*Note: the most complete illustration of different manual testing
concepts can be found in the tests for the MRM component.*

### Helper functions for setting up pre-state and retrieve post-state

Like the Slang infrastructure, we need helper functions for working
with pre/post state.  

The pre-state function should
  * take as arguments desired HAMR values to place on the input ports
    (with an alternate version to also set internal state variables
    for the component)
  * put the supplied values into the ports (and local state variable)  


The pre-state function suggested by Grok form MRM
[here](https://github.com/loonwerks/INSPECTA-models/blob/3ab96b7b51869903ff84baf34830b758c486a8ff/isolette/hamr/microkit/crates/thermostat_rt_mrm_mrm/src/tests.rs#L24-L52)
is going in the right direction, but isn't exactly like we want
because:
* it takes in primitive value types like Rust bool instead of the HAMR
  types for ports (it builds the HAMR types inside the helper
  function). This is actually very convenient for the developer, but I
  don't see how we would automate this in general.  It would be more
  uniform to take the HAMR types as parameters (I think this is what
  the Slang set up functions do)
* Grok discovered that some of the input elements (like the actual
  current temperature) are actually irrelevant to the test (or at
  least, the same value was always being called in the manual tests
  that it was generalizing from), so it hard-coded the value.  This
  would be hard to automate.  So again, the helper function shouldn't
  hardcode values like that.  If the user wants something like that,
  they would write their own function.
* Note: I think it is useful to be able to supply the parameters to
  these functions "by parameter name" (for readability) instead of
  just positionally.
* The Grok-generated helper for the pre-state returns the constructed
  HAMR values in a tuple.  I'm note sure we need that if we require
  HAMR values to be passed in as arguments.

The post-state function should return HAMR values for output ports and
local state.  The one proposed by Grok seems pretty close to what we
would want (see
[here](https://github.com/loonwerks/INSPECTA-models/blob/3ab96b7b51869903ff84baf34830b758c486a8ff/isolette/hamr/microkit/crates/thermostat_rt_mrm_mrm/src/tests.rs#L56-L68))

### Helper function for Manual CB Test

The idea here is to have a helper function for running a manual contract-based
test (probably want two versions - one that includes inputs for local
state and one that doesn't).
* takes HAMR-valued inputs corresponding to input port values (and
  local state) 
* evaluates the pre-condition (returns with an appropriate status
  value if pre-condition values ?? not sure how this would work,
  my assumption is that in the manual setting, we want the user to
  know if they have designed an input test vector that doesn't satisfy
  the pre-condition)
* sets the input state
* invokes the entry point
* retrieves output state
* asserts post-condition on input and output state


Something similar is
[here](https://github.com/loonwerks/INSPECTA-models/blob/3ab96b7b51869903ff84baf34830b758c486a8ff/isolette/hamr/microkit/crates/thermostat_rt_mrm_mrm/src/tests.rs#L122-L143)
but it isn't exactly what we want (it doesn't take HAMR values as
inputs in all cases).






## Additional Desired shortcuts / coding helps

- hints to list component input, output ports, along with internal
  declared state; dictation command to read all ports or read a
  particular port 

## Isolette Document / Code Errors

- current_temp input port is not used in MMI (not referenced by
  component requirements), even though it is depicted as input in
  Figure A-5.  It might be the case that its status value is supposed
  to be checked, but that is missing from the component requirements
  (and implementation).
- Slang code has comments for MMI e.g., 
  "Set values for Alarm Range internal variable" that inappropriately
  focus on the "internal variable" rather than the output.





